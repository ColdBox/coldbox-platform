<cfcomponent name="BaseConfigObject" output="false" hint="A base configuration object for lightwire"><!----------------------------------------- CONSTRUCTOR ------------------------------------->		<cfscript>		instance = structnew();	</cfscript>	<!--- Init --->	<cffunction name="init" returntype="BaseConfigObject" hint="I initialize default LightWire config properties." output="false">		<cfscript>			/* Default DI Lazy Load */			instance.LazyLoad = true;			/* Default Bean Lazy Init */			instance.defaultBeanLazyInit = true;			/* Setup the NonLazyBeans struct */			instance.nonLazyBeans = structnew();			/* Setup the default Config Struct */			instance.config = structnew();						/* instance */			return this;		</cfscript>	</cffunction>	<!----------------------------------------- PUBLIC ------------------------------------->			<!--- get the config struct --->	<cffunction name="getConfigStruct" returntype="struct" hint="I provide LightWire with the properly configured configuration struct to operate on." output="false">		<cfreturn instance.config>	</cffunction>	<!--- Set the config Struct --->	<cffunction name="setConfigStruct" access="public" output="false" returntype="void" hint="Set or override the configuration struct.">
		<!---************************************************************************************************ --->		<cfargument name="ConfigStruct" type="struct" required="true"/>
		<!---************************************************************************************************ --->		<cfset instance.config = arguments.ConfigStruct/>
	</cffunction>		<!--- Set the lazy Load --->	<cffunction name="setLazyLoad" returntype="void" hint="I set whether Singletons should or shouldn't be laxy loaded." output="false">		<!---************************************************************************************************ --->		<cfargument name="LazyLoad" required="true" type="boolean" hint="Whether or not to use lazy loading of Singletons.">		<!---************************************************************************************************ --->		<cfset instance.LazyLoad = LazyLoad>	</cffunction>			<!--- Get the Lazy Load --->	<cffunction name="getLazyLoad" returntype="boolean" hint="I return whether Singletons should or shouldn't be lazy loaded." output="false">		<cfreturn instance.LazyLoad>	</cffunction>		<!--- Get the non lazy beans --->	<cffunction name="getnonLazyBeans" access="public" output="false" returntype="struct" hint="Get the non Lazy Beans">
		<cfreturn instance.nonLazyBeans/>
	</cffunction>		<!--- Add a Singleton --->	<cffunction name="addSingleton" returntype="void" hint="I add the configuration properties for a Singleton." output="false">		<!---************************************************************************************************ --->		<cfargument name="FullClassPath" 	required="true"  type="string" 					hint="The full class path to the bean including its name. E.g. for com.UserService.cfc it would be com.UserService.">		<cfargument name="BeanName" 		required="false" type="string"	default="" 		hint="An optional name to be able to use to refer to this bean. If you don't provide this, the name of the bean will be used as a default. E.g. for com.UserService, it'll be named UserService unless you put something else here. If you put UserS, it'd be available as UserS, but NOT as UserService.">		<cfargument name="InitMethod" 		required="false" type="string"	default="" 		hint="A default custom initialization method for LightWire to call on the bean after constructing it fully (including setter and mixin injection) but before returning it.">		<cfargument name="Lazy" 			required="false" type="boolean" default="#instance.defaultBeanLazyInit#"	hint="Whether to construct at startup or not.">		<cfargument name="BeanType" 		required="false" type="string" 	default=""		hint="The bean type: cfc, java, webservice">		<!---************************************************************************************************ --->		<cfscript>			arguments.Singleton = 1;			addBean(argumentCollection=arguments);		</cfscript>	</cffunction>		<!--- Add a Transient Object --->	<cffunction name="addTransient" returntype="void" hint="I add the configuration properties for a Transient." output="false">		<!---************************************************************************************************ --->		<cfargument name="FullClassPath" 	required="true"  type="string" 				hint="The full class path to the bean including its name. E.g. for com.User.cfc it would be com.User.">		<cfargument name="BeanName" 		required="false" type="string" default=""  	hint="An optional name to be able to use to refer to this bean. If you don't provide this, the name of the bean will be used as a default. E.g. for com.User, it'll be named User unless you put something else here. If you put UserBean, it'd be available as UserBean, but NOT as User.">		<cfargument name="InitMethod" 		required="false" type="string" default="" 	hint="A default custom initialization method for LightWire to call on the bean after constructing it fully (including setter and mixin injection) but before returning it.">			<cfargument name="BeanType" 		required="false" type="string" default=""	hint="The bean type: cfc, java, webservice">		<!---************************************************************************************************ --->		<cfscript>			arguments.singleton = 0;			arguments.lazy = true;			addBean(argumentCollection=arguments);		</cfscript>	</cffunction>		<!--- Add a Bean --->	<cffunction name="addBean" returntype="void" hint="I add the configuration properties for a Singleton or Transient." output="false">		<!---************************************************************************************************ --->		<cfargument name="FullClassPath" 	required="true" 	type="string" 					hint="The full class path to the bean including its name. E.g. for com.UserService.cfc it would be com.UserService.">		<cfargument name="BeanName" 		required="false" 	type="string" 	default="" 		hint="An optional name to be able to use to refer to this bean. If you don't provide this, the name of the bean will be used as a default. E.g. for com.UserService, it'll be named UserService unless you put something else here. If you put UserS, it'd be available as UserS, but NOT as UserService.">		<cfargument name="Singleton" 		required="true" 	type="boolean"					hint="Whether the bean is a Singleton (1) or Transient(0).">		<cfargument name="InitMethod" 		required="false" 	type="string" 	default="" 		hint="A default custom initialization method for LightWire to call on the bean after constructing it fully (including setter and mixin injection) but before returning it.">			<cfargument name="Lazy" 			required="false" 	type="boolean" 	default="#instance.defaultBeanLazyInit#"	hint="Whether to construct at startup or not.">		<cfargument name="BeanType" 		required="false" 	type="string" 	default=""		hint="The bean type: cfc, java, webservice">		<!---************************************************************************************************ --->		<cfscript>			var beanDefintion = getBeanDefinition();						// Default the name to the name of the bean if no name list is provided.			If (Len(trim(arguments.BeanName)) LT 1){				arguments.BeanName = ListLast(arguments.FullClassPath,".");			}						/* Setup Arguments */			beanDefintion.Singleton = arguments.Singleton;			beanDefintion.Path = arguments.FullClassPath;			beanDefintion.InitMethod = arguments.InitMethod;			beanDefintion.Lazy = arguments.Lazy;						/* Verify beanType */			beanDefintion.Type = validateBeanType(arguments.beanType);						/* Add to non lazy beans? */			if( not arguments.Lazy ){				addToNonLazyBeans(arguments.BeanName);			}						/* Save in Config */			instance.config[arguments.BeanName] = beanDefintion;		</cfscript>	</cffunction>		<!--- Add a Singleton From a Factory --->	<cffunction name="addSingletonFromFactory" returntype="void" hint="Adds the definition for a given Singleton that is created by a factory to the config file." output="false">		<!---************************************************************************************************ --->		<cfargument name="FactoryBean" 		required="true" 	type="string" hint="The name of the factory to use to create this bean (the factory must also have been defined as a Singleton in the LightWire config file).">		<cfargument name="FactoryMethod" 	required="true" 	type="string" hint="The name of the method to call on the factory bean to create this bean.">		<cfargument name="BeanName" 		required="true" 	type="string" hint="The required name to use to refer to this bean.">		<cfargument name="Lazy" 			required="false" 	type="boolean" 	default="#instance.defaultBeanLazyInit#"	hint="Whether to construct at startup or not.">		<!---************************************************************************************************ --->		<cfscript>			addBeanFromFactory(FactoryBean, FactoryMethod, BeanName, 1);		</cfscript>	</cffunction>		<!--- Add a transient from a factory --->	<cffunction name="addTransientFromFactory" returntype="void" hint="Adds the definition for a given Transient that is created by a factory to the config file." output="false">		<!---************************************************************************************************ --->		<cfargument name="FactoryBean" 		required="true" type="string" hint="The name of the factory to use to create this bean (the factory must also have been defined as a Singleton in the LightWire config file).">		<cfargument name="FactoryMethod" 	required="true" type="string" hint="The name of the method to call on the factory bean to create this bean.">		<cfargument name="BeanName" 		required="true" type="string" hint="The required name to use to refer to this bean.">		<!---************************************************************************************************ --->		<cfscript>			addBeanFromFactory(FactoryBean, FactoryMethod, BeanName, 0);		</cfscript>	</cffunction>		<!--- Add From Factory --->	<cffunction name="addBeanFromFactory" returntype="void" hint="I add the configuration properties for a Singleton or Transient that is created by a factory to the config file." output="false">		<!---************************************************************************************************ --->		<cfargument name="FactoryBean" 		required="true" 	type="string" 	hint="The name of the factory to use to create this bean (the factory must also have been defined as a Singleton in the LightWire config file).">		<cfargument name="FactoryMethod" 	required="true" 	type="string" 	hint="The name of the method to call on the factory bean to create this bean.">		<cfargument name="BeanName" 		required="true" 	type="string" 	hint="The required name to use to refer to this bean.">		<cfargument name="Singleton" 		required="true" 					hint="Whether the bean is a Singleton (1) or Transient(0).">		<cfargument name="Lazy" 			required="false" 	type="boolean" 	default="#instance.defaultBeanLazyInit#"	hint="Whether to construct at startup or not.">		<!---************************************************************************************************ --->		<cfscript>			var beanDefintion = getBeanDefinition();						/* Setup Arguments. */			beanDefintion.Singleton = arguments.Singleton;			beanDefintion.FactoryBean = arguments.FactoryBean;			beanDefintion.FactoryMethod = arguments.FactoryMethod;			beanDefintion.isFactoryBean = true;			beanDefintion.Lazy = arguments.Lazy;			beanDefintion.Type = "cfc";						/* Add to non lazy beans? */			if( not arguments.Lazy ){				addToNonLazyBeans(arguments.BeanName);			}						/* Save in Config */			instance.config[arguments.BeanName] = beanDefintion;		</cfscript>	</cffunction>		<!--- Add a constructor Dependency --->	<cffunction name="addConstructorDependency" returntype="void" hint="I add a constructor object dependency for a bean." output="false">		<!---************************************************************************************************ --->		<cfargument name="BeanName" 		required="true"	 	type="string" 				hint="The name of the bean to set the constructor dependencies for.">		<cfargument name="InjectedBeanName" required="true" 	type="string" default="" 	hint="The name of the bean to inject.">		<cfargument name="PropertyName" 	required="false" 	type="string" default="" 	hint="The optional property name to pass the bean into. Defaults to the bean name if not provided.">		<!---************************************************************************************************ --->		<cfscript>			// Add the constructor dependencies			instance.config[BeanName].ConstructorDependencies = ListAppend(instance.config[BeanName].ConstructorDependencies, InjectedBeanName);			If (len(PropertyName) LT 1)			{PropertyName = InjectedBeanName;};			instance.config[BeanName].ConstructorDependencyStruct[InjectedBeanName] = PropertyName;		</cfscript>	</cffunction>		<!--- Add a constructor property --->	<cffunction name="addConstructorProperty" returntype="void" hint="I add a constructor property of any type to a bean." output="false">		<!---************************************************************************************************ --->		<cfargument name="BeanName" 		required="true" type="string" 	hint="The name of the bean to add the property to.">		<cfargument name="PropertyName" 	required="true" type="string" 	hint="The name of the property to set.">		<cfargument name="PropertyValue" 	required="true" type="any" 		hint="The value of the property to set.">		<!---************************************************************************************************ --->		<cfscript>			// Add the constructor property			instance.config[BeanName].ConstructorProperties[PropertyName] = PropertyValue;		</cfscript>	</cffunction>		<!--- Add a Setter Dependency --->	<cffunction name="addSetterDependency" returntype="void" hint="I add a setter dependency for a bean." output="false">		<!---************************************************************************************************ --->		<cfargument name="BeanName" 		required="true"  type="string" 			  hint="The name of the bean to set the setter dependencies for.">		<cfargument name="InjectedBeanName" required="true"  type="string" default="" hint="The name of the bean to inject.">		<cfargument name="PropertyName" 	required="false" type="string" default="" hint="The optional property name to pass the bean into. Defaults to the bean name if not provided.">		<!---************************************************************************************************ --->		<cfscript>			// Add the setter dependencies			instance.config[BeanName].SetterDependencies = ListAppend(instance.config[BeanName].SetterDependencies, InjectedBeanName);			If (len(PropertyName) LT 1)			{PropertyName = InjectedBeanName;};			instance.config[BeanName].SetterDependencyStruct[InjectedBeanName] = PropertyName;		</cfscript>	</cffunction>		<!--- Add a setter property --->	<cffunction name="addSetterProperty" returntype="void" hint="I add a setter property of any type to a bean." output="false">		<!---************************************************************************************************ --->		<cfargument name="BeanName" 		required="true" type="string" 	hint="The name of the bean to add the property to.">		<cfargument name="PropertyName" 	required="true" type="string" 	hint="The name of the property to set.">		<cfargument name="PropertyValue" 	required="true" type="any" 		hint="The value of the property to set.">		<!---************************************************************************************************ --->		<cfscript>			// Add the setter property			instance.config[BeanName].SetterProperties[PropertyName] = PropertyValue;		</cfscript>	</cffunction>		<!--- Add a mixin dependency --->	<cffunction name="addMixinDependency" returntype="void" hint="I add a mixin dependency for a bean." output="false">		<!---************************************************************************************************ --->		<cfargument name="BeanName" 		required="true" 	type="string" 				hint="The name of the bean to set the mixin dependencies for.">		<cfargument name="InjectedBeanName" required="true" 	type="string" default="" 	hint="The name of the bean to inject.">		<cfargument name="PropertyName" 	required="false" 	type="string" default="" 	hint="The optional property name to pass the bean into. Defaults to the bean name if not provided.">		<!---************************************************************************************************ --->		<cfscript>			// Add the mixin dependencies			instance.config[BeanName].MixinDependencies = ListAppend(instance.config[BeanName].MixinDependencies, InjectedBeanName);			If (len(PropertyName) LT 1)			{PropertyName = InjectedBeanName;};			instance.config[BeanName].MixinDependencyStruct[InjectedBeanName] = PropertyName;		</cfscript>	</cffunction>			<!--- Add a mixin property --->	<cffunction name="addMixinProperty" returntype="void" hint="I add a mixin property of any type to a bean." output="false">		<!---************************************************************************************************ --->		<cfargument name="BeanName" 		required="true" type="string" 	hint="The name of the bean to add the property to.">		<cfargument name="PropertyName" 	required="true" type="string" 	hint="The name of the property to set.">		<cfargument name="PropertyValue" 	required="true" type="any" 		hint="The value of the property to set.">		<!---************************************************************************************************ --->		<cfscript>			// Add the mixin property			instance.config[BeanName].MixinProperties[PropertyName] = PropertyValue;		</cfscript>	</cffunction>		<!--- Parse a Coldspring XML --->	<cffunction name="parseXMLConfigFile" returntype="void" hint="I take the path to a ColdSpring XML config file and use it to set all of the necessary LightWire config properties." output="false">		<!---************************************************************************************************ --->		<cfargument name="XMLFilePath" 	required="true" 	type="string" hint="The path to the XML config file.">		<cfargument name="properties" 	required="false" 	type="struct" hint="A struct of default properties to be used in place of ${key} in XML config file.">		<!---************************************************************************************************ --->		<cfscript>			var i = 0;			// parse coldspring xml bean config			var xml = XMLParse(arguments.XMLFilePath,false);			// use XMLSearch to create array of all bean defs			var beans = XMLSearch(xml,'/beans/bean');						/* default-lazy-init? */			if( structKeyExists(xml.beans.XMLAttributes,"default-lazy-init") AND			    isBoolean(trim(xml.beans.XMLAttributes["default-lazy-init"])) ){				/* Set the lazy load argument. */				setLazyLoad(trim(xml.beans.XMLAttributes["default-lazy-init"]));			}						// loop over beans to create singleton or transient			for (i = 1; i lte ArrayLen(beans); i = i + 1){				/* Translate with or without properties */				if (structKeyExists(arguments,"properties")){					translateBean(beans[i],arguments.properties);				}				else{					translateBean(beans[i]);				}			}		</cfscript>	</cffunction>		<!--- Translate a bean definition --->	<cffunction name="translateBean" access="private" output="false" returntype="void" hint="I translate ColdSpring XML bean definitiions to LightWire config.">		<!---************************************************************************************************ --->		<cfargument name="bean" 		type="xml" 		required="true"  hint="The xml bean definition">		<cfargument name="properties" 	type="struct" 	required="false" hint="The properties structure">		<!---************************************************************************************************ --->		<cfscript>			var beanStruct = StructNew();			var key = "";						// loop over bean tag attributes and create beanStruct keys			For (key in bean.XmlAttributes){				if (key eq "factory-bean"){					beanStruct.FactoryBean = trim(bean.XmlAttributes[key]);				}				if (key eq "factory-method"){					beanStruct.FactoryMethod = trim(bean.XmlAttributes[key]);				}				if (key eq "singleton"){					beanStruct.Singleton = trim(bean.XmlAttributes[key]);				}				if (key eq "class"){					beanStruct.FullClassPath = trim(bean.XmlAttributes[key]);				}				if (key eq "type"){					beanStruct.BeanType = trim(bean.XmlAttributes[key]);				}				if (key eq "id"){					beanStruct.BeanName = trim(bean.XmlAttributes[key]);				}				if (key eq "init-method"){					beanStruct.InitMethod = trim(bean.XmlAttributes[key]);				}							if (key eq "lazy-init"){					beanStruct.Lazy = trim(bean.XmlAttributes[key]);				}				else{					beanStruct.Lazy = instance.defaultBeanLazyInit;				}			}//end loop over xml attributes						/* Add to non lazy beans? */			if( not beanStruct.Lazy ){				addToNonLazyBeans(beanStruct.beanName);			}			/* Check if Singleton defined, if not, set to default of true */			if( not structKeyExists(beanStruct,"Singleton") ){				beanStruct.Singleton = true;			}						// If not a singleton			if ( not beanStruct.Singleton ){				// if beanStruct contains key FactoryBean, then create transient from factory 				if (structKeyExists(beanStruct,"FactoryBean")){					addTransientFromFactory(argumentCollection=beanStruct);				}				else{					addTransient(argumentCollection=beanStruct);				}			}			else{				// if beanStruct contains key FactoryBean, then create singleton from factory				if (structKeyExists(beanStruct,"FactoryBean")){					addSingletonFromFactory(argumentCollection=beanStruct);				}				else{					addSingleton(argumentCollection=beanStruct);				}			}			/* Property Checks */			if (structKeyExists(arguments,"properties")){				// add constructor dependecies and properties				translateBeanChildren(arguments.bean,'constructor-arg',arguments.properties);				// add setter dependecies and properties				translateBeanChildren(arguments.bean,'property',arguments.properties);				// add mixin dependecies and properties				translateBeanChildren(arguments.bean,'mixin',arguments.properties);			}			else{				// add constructor dependecies and properties				translateBeanChildren(arguments.bean,'constructor-arg');				// add setter dependecies and properties				translateBeanChildren(arguments.bean,'property');				// add mixin dependecies and properties				translateBeanChildren(arguments.bean,'mixin');			}					</cfscript>	</cffunction>		<!--- Translate bean children --->	<cffunction name="translateBeanChildren" access="private" output="false" returntype="void">		<!---************************************************************************************************ --->		<cfargument name="bean" 		type="XML" 		required="true">		<cfargument name="childTagName" type="string" 	required="true">		<cfargument name="props" 		type="struct" 	required="false">		<!---************************************************************************************************ --->		<cfscript>			var children = "";			var entries = "";			var hashMap = "";			var property = "";			var key = "";			var i = 1;			var j = 1;			// find all constructor properties and dependencies			children = XMLSearch(bean,arguments.childTagName);			for (i = 1; i lte ArrayLen(children); i = i + 1)			{				// child element "value"				if (structKeyExists(children[i],"value")){					if ( structKeyExists(arguments,"props") and structKeyExists(arguments.props, children[i].XmlAttributes["name"]) ){						property = arguments.props[ReplaceList(children[i].value.XmlText,"${,}",",")];					}					else{						property = children[i].value.XmlText;					};					switch (arguments.childTagName) 					{						case 'constructor-arg' :						{							addConstructorProperty(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],property);						};						break;						case 'property' :						{							addSetterProperty(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],property);						};						break;						case 'mixin' :						{							addMixinProperty(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],property);						};						break;					};									};				// child element "map"				if (structKeyExists(children[i],"map"))				{					entries = XMLSearch(children[i],'map/entry');					hashMap = structNew();					for (j = 1; j lte ArrayLen(entries); j = j + 1)					{						if (structKeyExists(entries[j],"value"))						{							hashMap[entries[j].XmlAttributes["key"]] = entries[j].value.XmlText;						} 						else if (structKeyExists(entries[j],"ref"))						{							hashMap[entries[j].XmlAttributes["key"]] = entries[j].ref.XmlAttributes["bean"];						}					}					switch (arguments.childTagName)					{						case 'constructor-arg' :						{							addConstructorProperty(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],hashMap);						};						break;						case 'property' :						{							addSetterProperty(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],hashMap);						};						break;						case 'mixin' :						{							addMixinProperty(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],hashMap);						};						break;					};				};				// child element "ref"				if (structKeyExists(children[i],"ref"))				{					switch (arguments.childTagName)					{						case 'constructor-arg' :						{							addConstructorDependency(bean.XmlAttributes["id"],children[i].ref.XmlAttributes["bean"],children[i].XmlAttributes["name"]);						};						break;						case 'property' :						{							addSetterDependency(bean.XmlAttributes["id"],children[i].ref.XmlAttributes["bean"],children[i].XmlAttributes["name"]);						};						break;						case 'mixin' :						{							addMixinDependency(bean.XmlAttributes["id"],children[i].ref.XmlAttributes["bean"],children[i].XmlAttributes["name"]);						};						break;					};				};				//child element "bean"				if (structKeyExists(children[i],"bean"))				{					// use recursion					if (structKeyExists(arguments,"props"))					{						translateBean(children[i].bean,arguments.props);					}					else					{						translateBean(children[i].bean);					}					switch (arguments.childTagName)					{						case 'constructor-arg' :						{							addConstructorDependency(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],children[i].bean.XmlAttributes["id"]);						};						break;						case 'property' :						{							addSetterDependency(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],children[i].bean.XmlAttributes["id"]);						};						break;						case 'mixin' :						{							addMixinDependency(bean.XmlAttributes["id"],children[i].XmlAttributes["name"],children[i].bean.XmlAttributes["id"]);						};						break;					};				};			};		</cfscript>	</cffunction><!----------------------------------------- PRIVATE ------------------------------------->				<cffunction name="getBeanDefinition" access="private" returntype="struct" hint="Get a structure with a bean's definitions by default." output="false" >
		<cfscript>		var definition = structnew();				/* Initialize Main Bean Properties */		definition.Singleton = true;		definition.Path = "";		definition.InitMethod = "";		definition.Lazy = instance.defaultBeanLazyInit;		definition.Type = "cfc";				/* Factory Bean Defaults */		definition.FactoryBean = "";		definition.FactoryMethod = "";		definition.isFactoryBean = false;				/*  Initialize the dependency lists */		definition.ConstructorDependencies = "";		definition.SetterDependencies = "";		definition.MixinDependencies = "";		/* Initialize the dependency structs */		definition.ConstructorDependencyStruct = StructNew();		definition.SetterDependencyStruct = StructNew();		definition.MixinDependencyStruct = StructNew();				return definition;		</cfscript>	</cffunction>		<!--- Validate Bean Type --->	<cffunction name="validateBeanType" access="private" returntype="string" hint="Validate an incoming bean type" output="false" >		<!---************************************************************************************************ --->		<cfargument name="BeanType" required="true" type="string" hint="The bean type: cfc, java, webservice">		<!---************************************************************************************************ --->		<cfscript>			/* Check if we have something */			if( len(trim(arguments.beanType)) ){				if( not reFindnocase("^(cfc|java|webservice)$",arguments.BeanType) ){					throwit("Invalid beantype: #arguments.beanType#","The only valid beanTypes are cfc,java and webservice","baseConfigObject.invalidBeanType");				}				else{					/* Setup the Type */					return arguments.beanType;				}			}			/* Return Default */			return "cfc";		</cfscript>	</cffunction>		<!--- Add beans to the non lazy struct --->	<cffunction name="addToNonLazyBeans" access="private" returntype="void" hint="Add to non lazy beans struct" output="false" >		<cfargument name="beanName" required="true" type="string" hint="The bean name">		<cfset instance.nonLazyBeans[arguments.beanName] = arguments.beanName>	</cffunction>		<!--- Dump it Facade --->	<cffunction name="dumpit" access="private" hint="Facade for cfmx dump" returntype="void">		<cfargument name="var" required="yes" type="any">		<cfargument name="abort" type="boolean" required="false" default="false"/>		<cfdump var="#var#"><cfif abort><cfabort></cfif>	</cffunction>	<!--- Abort Facade --->	<cffunction name="abortit" access="private" hint="Facade for cfabort" returntype="void" output="false">		<cfabort>	</cffunction>	<!--- Throw Facade --->	<cffunction name="throwit" access="private" hint="Facade for cfthrow" output="false">		<!--- ************************************************************* --->		<cfargument name="message" 	type="string" 	required="yes">		<cfargument name="detail" 	type="string" 	required="no" default="">		<cfargument name="type"  	type="string" 	required="no" default="Framework">		<!--- ************************************************************* --->		<cfthrow type="#arguments.type#" message="#arguments.message#"  detail="#arguments.detail#">	</cffunction></cfcomponent>