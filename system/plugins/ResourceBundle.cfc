<!-----------------------------------------------------------------------********************************************************************************Copyright Since 2005 ColdBox Framework by Luis Majano and Ortus Solutions, Corpwww.coldbox.org | www.luismajano.com | www.ortussolutions.com********************************************************************************author:         paul hastings <paul@sustainableGIS.com>date:           08-december-2003revisions:      15-mar-2005     fixed un-scoped var variable in formatRBString method.                       4-mar-2006      added messageFormat method to                       8-jul-2006 coldbox versionnotes:          the purpose of this CFC is to extract text resources from a pure java resource bundle. these                       resource bundles should be produced by a tools such as IBM's rbManager and consist of:                               key=ANSI escaped string such as                               (english, no need for ANSI escaped chars)                               Cancel=Cancel                               Go=Ok                               (thai, ANSI escaped chars)                               Cancel=\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01                               Go=\u0E44\u0E1Bmethods in this CFC:       - getResourceBundle returns a structure containing all key/messages value pairs in a given resource       bundle file. required argument is rbFile containing absolute path to resource bundle file. optional       argument is rbLocale to indicate which locale's resource bundle to use, defaults to us_EN (american       english). PUBLIC       - getRBKeys returns an array holding all keys in given resource bundle. required argument is rbFile       containing absolute path to resource bundle file. optional argument is rbLocale to indicate which       locale's resource bundle to use, defaults to us_EN (american english). PUBLIC       - getRBString returns string containing the text for a given key in a given resource bundle. required       arguments are rbFile containing absolute path to resource bundle file and rbKey a string holding the       required key. optional argument is rbLocale to indicate which locale's resource bundle to use, defaults       to us_EN (american english). PUBLIC       - formatRBString returns string w/dynamic values substituted. performs messageFormat like       operation on compound rb string: "You owe me {1}. Please pay by {2} or I will be forced to       shoot you with {3} bullets." this function will replace the place holders {1}, etc. with       values from the passed in array (or a single value, if that's all there are). required       arguments are rbString, the string containing the placeholders, and substituteValues either       an array or a single value containing the values to be substituted. note that the values       are substituted sequentially, all {1} placeholders will be substituted using the first       element in substituteValues, {2} with the  second, etc. DEPRECATED. only retained for       backwards compatibility. please use messageFormat method instead.       - messageFormat returns string w/dynamic values substituted. performs MessageFormat       operation on compound rb string.  required arguments: pattern string to use as pattern for       formatting, args array of "objects" to use as substitution values. optional argument is       locale, java style locale       ID, "th_TH", default is "en_US". for details about format       options please see http://java.sun.com/j2se/1.4.2/docs/api/java/text/MessageFormat.html       - verifyPattern verifies MessageFormat pattern. required argument is pattern a string       holding the MessageFormat pattern to test. returns a boolean indicating if the pattern is       ok or not. PUBLICModifications08/20/2006 Luis Majano - Modified for ColdBox-----------------------------------------------------------------------><cfcomponent hint="Reads and parses java resource bundles per locale"			 extends="coldbox.system.Plugin"			 output="false"			 singleton><!------------------------------------------- CONSTRUCTOR ------------------------------------------->	<cffunction name="init" access="public" returntype="ResourceBundle" hint="Constructor" output="false">		<cfargument name="controller" type="any" required="true">		<cfscript>			super.Init(arguments.controller);						setpluginName("Resource Bundle");			setpluginVersion("2.0 coldbox core java");			setpluginDescription("Java Style Resource Bundles plugin based on Paul Hastings Brain.");			setpluginAuthor("Luis Majano");			setpluginAuthorURL("http://www.coldbox.org");						// set instance properties			if( NOT settingExists("RBundles") ){ setSetting("RBundles",structNew()); }			instance.RBundles				= controller.getSetting("RBundles");			instance.defaultLocale 			= controller.getSetting("DefaultLocale");			instance.defaultResourceBundle  = controller.getSetting("DefaultResourceBundle");			instance.unknownTranslation 	= controller.getSetting("UnknownTranslation");						return this;		</cfscript>	</cffunction><!------------------------------------------- PUBLIC ------------------------------------------->	<cffunction name="loadBundle" access="public" output="false" hint="Reads,parses and saves the resource bundle per locale in internal ColdBox structures." returntype="void">		<cfargument name="rbFile"   required="true" type="string" hint="This must be the path + filename UP to but NOT including the locale. We auto-add .properties to the end.">		<cfargument name="rbLocale" required="false"  type="string" default="en_US">		<cfscript>			var bundles = instance.RBundles;						// Setup the Bundles in the RBundles map according to locale			bundles[arguments.rbLocale] = getResourceBundle(arguments.rbFile,arguments.rbLocale);		</cfscript>	</cffunction>		<cffunction name="getResourceBundle" access="public" returntype="any" output="false" hint="Reads,parses and RETURNS a resource bundle in structure format">		<cfargument name="rbFile"   required="true"   type="any" hint="This must be the path + filename UP to but NOT including the locale. We auto-add the local and .properties to the end.">		<cfargument name="rbLocale" required="false"  type="any" default="en_US" hint="The locale of the resource bundle">		<cfscript>			var resourceBundle =structNew();			var thisKEY = "";			var thisMSG = "";			var keys = "";			var rbFilePath = arguments.rbFile & iif(len(arguments.rbLocale),de("_"),de("")) & arguments.rbLocale & ".properties";			var rbFullPath = rbFilePath;			var fis = "";			var rb = "";			var bundle = "";			// Try to locate the path using the coldbox plugin utility			rbFullPath = locateFilePath(rbFilePath);						// Validate Location			if( NOT len(rbFullPath) ){				$throw("The resource bundle file: #rbFilePath# does not exist. Please check your path","FullPath: #rbFullPath#","ResourceBundle.InvalidBundlePath");			}			//create a file input stream with file location			fis = createObject("java","java.io.FileInputStream").init(rbFullPath);			//Init RB with file Stream			rb = createObject("java","java.util.PropertyResourceBundle").init(fis);			//Get Keys			keys = rB.getKeys();			try{				//if locales already load + then additional/modified values from provided file				if(StructKeyExists(instance.RBundles, rbLocale)){					bundle = instance.RBundles[rbLocale];					//Loop through Keys and get the elements.					while (keys.hasMoreElements()) {						thisKEY = keys.nextElement();						thisMSG = rb.handleGetObject(thisKEY);						bundle["#thisKEY#"] = thisMSG;					}					resourceBundle = bundle;				}else{					//Loop through Keys and get the elements.					while (keys.hasMoreElements()) {						thisKEY = keys.nextElement();						thisMSG = rb.handleGetObject(thisKEY);						resourceBundle["#thisKEY#"] = thisMSG;					}				}			}			catch(Any e){				fis.close();				$rethrow(e);			}						// Close the input stream			fis.close();						return resourceBundle;		</cfscript>	</cffunction>		<cffunction name="getResource" access="public" output="false" returnType="any" hint="Returns bundle resource from loaded bundle, if it exists, according to locale. To get a resource string from non loaded RB's, use getRBString">		<cfargument name="resource" type="any" required="true" hint="The resource to retrieve from the loaded bundle.">		<cfargument name="default"  type="any" required="false" hint="A default value to send back if resource not found" >		<cfargument name="locale"   type="any" required="false" default="#getfwLocale()#" hint="Pass in which locale to take the resource from. By default it uses the user's current set locale" >		<cfscript>			var bundle = structnew();			var loadedBundles = instance.RBundles;			var thisLocale = arguments.locale;			var defaultLocale = instance.defaultLocale;						try{				// Check if the locale has a language bundle loaded?				if( not structKeyExists(loadedBundles,thisLocale) ){					// Try to load the language					loadBundle(instance.defaultResourceBundle,thisLocale);				}								// Get the language resource bundle now				bundle = loadedBundles[thisLocale];			}			catch(Any e){				$throw(message="Error getting language (#thisLocale#) bundle for resource (#arguments.resource#). Exception Message #e.message#",					   detail=e.detail & e.tagContext.toString(),					   type="ResourceBundle.BundleLoadingException");			}						// Check if resource does NOT exists?			if( NOT structKeyExists(bundle, arguments.resource) ){				// Default Bundle Check, if not loaded, reload it.				if( not structKeyExists(loadedBundles, defaultLocale) ){					loadBundle(instance.defaultResourceBundle,defaultLocale);				}				// target bundle is now the default locale				bundle = loadedBundles[defaultLocale];				// Check if resource is in default locale bundle now?				if( NOT structKeyExists(bundle,arguments.resource) ){					// Check default and return if sent					if( structKeyExists(arguments,"default") ){ return arguments.default; }					// Check unknown translation setting					if( len(instance.unknownTranslation) ){ return instance.unknownTranslation & " key: #arguments.resource#"; }					// Else return nasty unknown string.					return "_UNKNOWNTRANSLATION_FOR_#arguments.resource#_";				}			}						// Return Resource			return bundle[arguments.resource];		</cfscript>	</cffunction>		<cffunction name="getRBString" access="public" output="false" returntype="any" hint="returns text for given key in given java resource bundle per locale">		<cfargument name="rbFile" 	required="Yes" 	type="any" hint="This must be the path + filename UP to but NOT including the locale. We auto-add the local and .properties to the end.">		<cfargument name="rbKey" 	required="Yes" 	type="any" hint="The key to retrieve">		<cfargument name="rbLocale" required="No" 	type="any" default="" hint="The locale of the bundle. Default is en_US">		<cfargument name="default"  type="any" required="false" hint="A default value to send back if resource not found" >		<cfscript>			// text message to return			var rbString=""; 			var fis = "";			var rb = "";						// locale			if( NOT len(arguments.rbLocale) ){ arguments.rbLocale = instance.defaultLocale; }						//prepare the file	       	arguments.rbFile = arguments.rbFile & "_#arguments.rbLocale#.properties";			// Check if file exists			if ( NOT fileExists(arguments.rbFile) ){				$throw("Fatal error: resource bundle #arguments.rbFile# not found.","Locale sent: #arguments.rbLocale#","ResourceBundle.FileNotFoundException");			}						//read file			fis = createObject("java","java.io.FileInputStream").init(arguments.rbFile);			rb = createObject("java","java.util.PropertyResourceBundle").init(fis);						try{				// Retrieve string				rbString = rb.handleGetObject(arguments.rbKey);			}			catch(Any e){				fis.close();				$rethrow(e);			}						// Close file			fis.close();		    		    //Check if found?		    if( len(trim(rbString)) ){ return rbString; }		    // Check default?		    if( structKeyExists(arguments,"default") ){ return arguments.default; }		    		    // Nothing to return, throw it		    $throw("Fatal error: resource bundle #arguments.rbFile# does not contain key #arguments.rbKey#","","ResourceBundle.RBKeyNotFoundException");		</cfscript>	</cffunction>		<cffunction name="getRBKeys" access="public" output="false" returntype="array" hint="returns array of keys in java resource bundle per locale">		<cfargument name="rbFile" 	required="Yes" 	type="any" hint="This must be the path + filename UP to but NOT including the locale. We auto-add the local and .properties to the end.">		<cfargument name="rbLocale" required="No" 	type="any" default="" hint="The locale to use, if not passed, defaults to default locale.">		<cfscript>	       	var keys=arrayNew(1); // var to hold rb keys	       	var rbKeys="";	       	var fis = "";			var rb = "";						// default locale?			if( NOT len(arguments.rbLocale) ){ arguments.rbLocal = instance.defaultLocale; }				       	//prepare the file	       	arguments.rbFile = arguments.rbFile & "_#arguments.rbLocale#.properties";			// Check if file exists			if ( NOT fileExists(arguments.rbFile) ){				$throw("Fatal error: resource bundle #arguments.rbFile# not found.","Locale sent: #arguments.rbLocale#","ResourceBundle.FileNotFoundException");			}						//read file			fis = createObject("java","java.io.FileInputStream").init(arguments.rbFile);			rb = createObject("java","java.util.PropertyResourceBundle").init(fis);						//Get Keys			rbKeys = rb.getKeys();						//Loop through Keys and get the elements.            while (rbKeys.hasMoreElements()) {            	arrayAppend(keys,rbKeys.nextElement());            }                        //Close it up            fis.close();                        return keys;     	</cfscript>	</cffunction>		<cffunction name="formatRBString" access="public" output="false" returnType="string" hint="performs messageFormat like operation on compound rb string. So if you have a string with {1} it will replace it. You can also have multiple and send in an array to do replacements.">		<cfargument name="rbString" 		required="yes" type="string">	    <cfargument name="substituteValues" required="yes" type="any" hint="Array or single value to format.">	    <cfscript>	    	var x = 0;	    	var tmpStr = arguments.rbString;	    		    	// Array substitutions by position	    	if( isArray(arguments.substituteValues) ){	    		for(x=1; x lte ArrayLen(arguments.substituteValues); x=x+1){	    			tmpStr = replace(tmpStr,"{#x#}",arguments.substituteValues[x],"ALL");	    		}	    		return tmpStr;	    	}	    		    	// Single substitution	    	return replace(arguments.rbString,"{1}",arguments.substituteValues,"ALL");	    </cfscript>	</cffunction>		<cffunction name="messageFormat" access="public" output="false" returnType="string" hint="performs messageFormat on compound rb string">		<cfargument name="thisPattern" 	required="yes" type="string" hint="pattern to use in formatting">		<cfargument name="args" 		required="yes" hint="substitution values, simple or array">		<cfargument name="thisLocale" 	required="no"  default="" hint="locale to use in formatting, defaults to en_US">		<cfscript>			var pattern = createObject("java","java.util.regex.Pattern");			var regexStr="(\{[0-9]{1,},number.*?\})";			var p="";			var m="";			var i=0;			var thisFormat="";			var inputArgs = arguments.args;			var lang="";			var country="";			var variant="";			var tLocale="";						//locale?			if( NOT len(arguments.thisLocale) ){ arguments.thisLocale = instance.defaultLocale; }						//Create correct java locale			lang = listFirst(arguments.thisLocale,"_");	        country = listGetAt(arguments.thisLocale,2,"_");	        variant = listLast(arguments.thisLocale,"_");	        tLocale = createObject("java","java.util.Locale").init(lang,country,variant);	        	        // Check if input arguments not an array, then inflate to an array.	        if( NOT isArray(inputArgs) ){	        	inputArgs = listToArray(inputArgs);	        }	        	        // Create the message format	        thisFormat = createObject("java","java.text.MessageFormat").init(arguments.thisPattern,tLocale);	        			//let's make sure any cf numerics are cast to java datatypes	        p = pattern.compile(regexStr,pattern.CASE_INSENSITIVE);	        m = p.matcher(arguments.thisPattern);	        while( m.find() ){	        	i = listFirst(replace(m.group(),"{",""));	        	inputArgs[i]=javacast("float",inputArgs[i]);	        }	        	        arrayPrepend(inputArgs,"");	        return thisFormat.format(inputArgs.toArray());		</cfscript>	</cffunction>		<cffunction name="verifyPattern" access="public" output="no" returnType="boolean" hint="performs verification on MessageFormat pattern">    	<cfargument name="pattern" required="yes" type="string" hint="format pattern to test">		<cfscript>	        var test = "";	        	        try {	        	test = createObject("java","java.text.MessageFormat").init(arguments.pattern);	        }	        catch (Any e) {	            return false;	        }	        	        return true;		</cfscript>	</cffunction>		<cffunction name="getVersion" access="public" output="false" returntype="struct" hint="Returns version of this CFC and java library it uses.">		<cfscript>			var version = structnew();			var sys = createObject("java","java.lang.System");			version.ResourceBundleVersion = getPluginVersion();			version.javaRuntimeVersion = sys.getProperty("java.runtime.version");			version.javaVersion = sys.getProperty("java.version");						return version;		</cfscript>	</cffunction>	<!------------------------------------------- PRIVATE -------------------------------------------></cfcomponent>